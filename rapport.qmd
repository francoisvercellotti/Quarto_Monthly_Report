---
title: "üöñ Rapport Mensuel Courses de Taxi ‚Äî New York"
author: "Fran√ßois Vercellotti"
date: today

format:
  html:
    theme: cosmo
    toc: true
    toc-title: "Sommaire"
    toc-location: left
    toc-float: true
    number-sections: true
    code-fold: true
    code-summary: "Afficher le code"
    self-contained: true
    html-math-method: mathjax
    page-layout: full
    fig-responsive: true
    include-in-header:
      text: |
        <style>
            /* Police et tailles g√©n√©rales */
            body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;  /* Augmentation de la taille de base */
            line-height: 1.6;
            }

            /* Titre principal */
            h1.title {
            font-size: 3em !important;  /* Titre principal plus grand */
            margin-bottom: 0.8em !important;
            font-weight: 600 !important;
            }

            /* Sous-titres - Respect de la hi√©rarchie */
            h2 {
            font-size: 2.2em !important;
            margin-top: 1.5em !important;
            }

            h3 {
            font-size: 1.8em !important;
            }

            h4 {
            font-size: 1.6em !important; /* Augment√© pour √™tre plus visible */
            }

            h5 {
            font-size: 1.4em !important; /* Augment√© proportionnellement */
            }

            /* Assure la hi√©rarchie des titres num√©rot√©s */
            .header-section-number {
            font-weight: 600;
            }

            /* CORRECTION: Forcer la taille pour chaque niveau de titre avec num√©ro de section */
            h1 .header-section-number,
            h1 .header-section-number ~ * {
            font-size: 1em !important; /* M√™me taille que h1 */
            }

            h2 .header-section-number,
            h2 .header-section-number ~ * {
            font-size: 1em !important; /* M√™me taille que h2 */
            }

            h3 .header-section-number,
            h3 .header-section-number ~ * {
            font-size: 1em !important; /* M√™me taille que h3 */
            }

            h4 .header-section-number,
            h4 .header-section-number ~ * {
            font-size: 1em !important; /* M√™me taille que h4 */
            }

            h5 .header-section-number,
            h5 .header-section-number ~ * {
            font-size: 1em !important; /* M√™me taille que h5 */
            }

            /* CORRECTION SP√âCIFIQUE: Assurer que 4.2 n'est jamais plus grand que 4. */
            .quarto-section-identifier {
            font-size: inherit !important;
            }

            /* Paragraphes */
            p {
            font-size: 1.1em;
            margin-bottom: 1.2em;
            }

            /* Conteneur principal */
            #quarto-content {
            max-width: 2000px;
            margin: 0 auto;
            padding: 0 2em;
            }

            /* Alignement des cellules de layout */
            .cell.quarto-layout-cell {
            padding-left: 0 !important;
            padding-right: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
            }

            /* Alignement g√©n√©ral */
            .quarto-title, .quarto-title-meta, .cell-output, .cell {
            text-align: left !important;
            margin-left: 0 !important;
            padding-left: 0 !important;
            }

            /* Figures : suppression de tout d√©calage lat√©ral */
            .figure,
            .figure-img,
            .cell-output-display,
            .plot-output,
            .plotly-graph-div,
            .bokeh,
            .altair-render,
            .ggplot {
            margin-left: 0 !important;
            margin-right: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow: visible !important;
            }

            /* Supprime les styles inline de centering de Plotly */
            .cell-output-display .plotly-graph-div[style*="margin"] {
            margin: 0 !important;
            }

            /* Pour les images/SVG de Matplotlib et autres */
            .cell-output-display img[width],
            .cell-output-display svg[width] {
            width: 100% !important;
            height: auto !important;
            margin: 0 !important;
            }

            /* R√©duction de la taille de la barre d'outils Plotly */
            .plotly .modebar {
            transform: scale(0.7) !important;
            transform-origin: top right !important;
            }

            .plotly .modebar-container {
            right: 5px !important;
            top: 5px !important;
            }

            .plotly .modebar-btn {
            width: 1.6em !important;
            height: 1.6em !important;
            padding: 0.2em !important;
            }

            .plotly .modebar-btn svg {
            transform: scale(0.7) !important;
            }

            /* Espacement et taille du code */
            pre, code {
            font-size: 0.95em;
            }

            .cell-output {
            font-size: 1.15em;
            margin-top: 1em;
            margin-bottom: 2em;
            }

            /* Table des mati√®res */
            #toc-title {
            font-size: 1.4em !important;
            font-weight: 600 !important;
            }

            #TOC {
            font-size: 1.05em;
            }
        </style>

jupyter: python3
params:
  month_code: "2023-07"

execute:
  fig-width: 10
  fig-height: 6
  fig-format: "retina"
  fig-responsive: true
  out-width: "100%"
---


# üìå Contexte et Objectifs

Ce rapport pr√©sente l'analyse de l'activit√© des taxis √† New York pour le mois s√©lectionn√©.

Les objectifs sont les suivants :

* Suivre les indicateurs cl√©s de performance (KPI) des courses : nombre de trajets, distances parcourues et dur√©es.
* Identifier les p√©riodes de forte activit√©.
* Analyser les tendances et variations dans l'activit√© des taxis.
* Fournir des visualisations claires pour faciliter la compr√©hension des donn√©es.

---

# üìä Donn√©es utilis√©es

Les analyses reposent sur les donn√©es suivantes :

* **Donn√©es Taxi** : informations sur les trajets (prise en charge, d√©pose, distance, dur√©e) pour le mois analys√©.

---

# üì• Pr√©paration et Traitement des Donn√©es

Les donn√©es taxi sont charg√©es pour analyse.

```{python}
import pandas as pd
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
import os
import re
import yaml
from scipy import stats
import numpy as np
import geopandas as gpd

# Lecture du fichier settings.yaml pour obtenir le mois du rapport
# Si le fichier n'est pas trouv√©, utilisez une valeur par d√©faut
try:
    with open("config/settings.yaml", 'r') as file:
        settings = yaml.safe_load(file)
        month_code = settings.get('report_month', '2023-07')
except Exception as e:
    print(f"‚ö†Ô∏è Erreur lors de la lecture du fichier settings.yaml: {e}")
    month_code = '2023-07'  # Valeur par d√©faut


# Conversion en format lisible
try:
    date_obj = datetime.strptime(month_code, "%Y-%m")
    month_name = date_obj.strftime("%B %Y")
except:
    month_name = "Inconnu"


# Chargement des donn√©es taxi uniquement
# üì¶ Chargement et nettoyage des donn√©es taxi
# Chargement des donn√©es taxi uniquement
try:
    df_taxi = pd.read_csv(f"data/{month_code}-taxi.csv", parse_dates=["pickup_datetime", "dropoff_datetime"])

    # Pr√©paration des donn√©es
    df_taxi["hour"] = df_taxi["pickup_datetime"].dt.hour
    df_taxi["weekday"] = df_taxi["pickup_datetime"].dt.day_name()
    df_taxi["date"] = df_taxi["pickup_datetime"].dt.date
    df_taxi["duration"] = (df_taxi["dropoff_datetime"] - df_taxi["pickup_datetime"]).dt.total_seconds() / 60

    # Filtrer les dur√©es n√©gatives ou aberrantes (>180 min)
    df_taxi = df_taxi[(df_taxi["duration"] > 0) & (df_taxi["duration"] < 180)]

    # Filtrer les distances aberrantes (>50 miles)
    df_taxi = df_taxi[df_taxi["trip_distance"] < 50]

    # Utilisation directe des donn√©es taxi pour l'analyse
    df = df_taxi.copy()
except Exception as e:
    print(f"‚ùå Erreur lors du chargement des donn√©es taxi: {e}")
    # Cr√©ation d'un DataFrame vide pour √©viter les erreurs
    df = pd.DataFrame(columns=[
        "pickup_datetime",
        "dropoff_datetime",
        "trip_distance",
        "passenger_count",
        "payment_type",
        "total_amount",
        "PULocationID",
        "DOLocationID",
        "tip_amount",
        "hour",
        "weekday",
        "date",
        "duration",
        "payment_method"
    ])

    print("‚ö†Ô∏è Aucune donn√©e taxi disponible, rapport limit√©")


```

```{python}
#| output: asis
# G√©n√©ration "√† la vol√©e" du bloc d'information sur la p√©riode en Markdown
print(f"## Configuration pour le rapport du mois de **{month_name}**")
print()
print(f"- üìÖ P√©riode d'analyse : **{month_name}**")
print(f"- üóìÔ∏è Code p√©riode : **{month_code}**")
print(f"- üìä Fichier de donn√©es : **data/{month_code}-taxi.csv**")
print(f"- üî¢ Nombre d'enregistrements : **{len(df):,}**")
# üìà Indicateurs Cl√©s de Performance (KPIs)
```

```{python}
#| echo: false

# Calcul des KPIs avec gestion des erreurs
if not df.empty:
    total_trips = len(df)
    avg_distance = df["trip_distance"].mean() if "trip_distance" in df.columns else 0
    avg_distance_rounded = round(avg_distance, 2)

    if "duration" in df.columns:
        avg_duration = df["duration"].mean()
        # Identification des heures de pointe bas√©e sur les donn√©es r√©elles
        hourly_trips = df.groupby("hour").size()
        peak_hours = hourly_trips.sort_values(ascending=False).head(3).index.tolist()
        peak_hours.sort()  # Trier les heures par ordre croissant
        peak_hours_str = ", ".join([f"{h}h" for h in peak_hours])
    else:
        avg_duration = 0
        peak_hours_str = "Non d√©termin√©"

    # Jour de la semaine le plus charg√©
    if "weekday" in df.columns:
        busiest_day = df.groupby("weekday").size().idxmax()
    else:
        busiest_day = "Non d√©termin√©"
else:
    total_trips = 0
    avg_distance = 0
    avg_distance_rounded = 0
    avg_duration = 0
    peak_hours_str = "Non d√©termin√©"
    busiest_day = "Non d√©termin√©"
```

```{python}
#| output: asis
# G√©n√©ration "√† la vol√©e" du bloc KPI en Markdown
print(f"## Rapport de trafic du mois de **{month_name}**")
print()
print(f"- üìä Nombre total de trajets‚ÄØ: **{total_trips:,}**")
print(f"- üõ£Ô∏è Distance moyenne parcourue‚ÄØ: **{avg_distance_rounded:.1f}** miles")
print(f"- ‚è±Ô∏è Dur√©e moyenne d‚Äôun trajet‚ÄØ: **{avg_duration:.1f}** minutes")
print(f"- üïò Heures de pointe‚ÄØ: **{peak_hours_str}**")
print(f"- üìÖ Jour le plus charg√©‚ÄØ: **{busiest_day}**")
```

# üìä Analyse de l'Activit√© par Heure de la Journ√©e

## Volume de trajets par heure

Ce graphique pr√©sente la r√©partition du nombre de trajets en fonction de l'heure de la journ√©e.

```{python}
#| fig-cap: " "

# V√©rification que df existe et contient la colonne "hour"
if 'df' in globals() and not df.empty and "hour" in df.columns:
    # Pr√©paration des donn√©es
    hourly_counts = df["hour"].value_counts().sort_index().reset_index()
    hourly_counts.columns = ["hour", "count"]

    # Heure avec le plus de trajets
    max_hour = hourly_counts.loc[hourly_counts["count"].idxmax()]

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(hourly_counts, x="hour", y="count",
                 labels={"hour": "Heure", "count": "Nombre de trajets"},
                 title=" ")

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            tickmode='linear',
            tick0=0,
            dtick=1,
            title=" "
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200
    )

    # Ajout d'annotation pour le pic
    fig.add_annotation(
        x=max_hour["hour"],
        y=max_hour["count"],
        text=f"Pic: {max_hour['count']:,} trajets",
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40
    )

    fig.show()

    # Stockage de l'information pour l'affichage
    peak_hour = int(max_hour["hour"])

    # D√©termination du message appropri√©
    if peak_hour < 6:
        observation_msg = f"Le pic d'activit√© est observ√© tr√®s t√¥t, √† **{peak_hour}h**, sugg√©rant une forte demande matinale."
    elif 6 <= peak_hour < 10:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, correspondant √† l'heure de pointe matinale."
    elif 10 <= peak_hour < 16:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, durant la p√©riode de mi-journ√©e."
    elif 16 <= peak_hour < 20:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, correspondant √† l'heure de pointe en fin de journ√©e."
    else:
        observation_msg = f"Le pic d'activit√© est observ√© en soir√©e, √† **{peak_hour}h**, sugg√©rant une forte demande nocturne."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des trajets par heure")
    observation_msg = "Donn√©es insuffisantes pour g√©n√©rer l'observation."
```

```{python}
#| output: asis

# Utilisation de la m√™me technique avec output: asis pour g√©n√©rer le bloc d'observation
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

## Distance moyenne parcourue par heure

```{python}
#| fig-cap: " "

if not df.empty and "hour" in df.columns and "trip_distance" in df.columns:
    # Calcul des distances moyennes par heure
    dist_hour = df.groupby("hour")["trip_distance"].mean().reset_index()

    # Identification de l'heure avec la distance moyenne maximale et minimale
    max_dist_hour = dist_hour.loc[dist_hour["trip_distance"].idxmax()]
    min_dist_hour = dist_hour.loc[dist_hour["trip_distance"].idxmin()]

    # Cr√©ation du graphique avec Plotly
    fig = go.Figure()

    # Ajout de la ligne principale
    fig.add_trace(go.Scatter(
        x=dist_hour["hour"],
        y=dist_hour["trip_distance"],
        mode='lines+markers',
        name='Distance moyenne',
        line=dict(color='royalblue', width=3),
        marker=dict(size=8)
    ))

    # Mise en forme du graphique
    fig.update_layout(
        title="Distance moyenne par heure",
        xaxis=dict(
            title=" ",
            tickmode='linear',
            tick0=0,
            dtick=1
        ),
        yaxis=dict(
            title="Distance moyenne (miles)"
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200
    )

    # Ajout d'annotations pour les points maximum et minimum
    fig.add_annotation(
        x=max_dist_hour["hour"],
        y=max_dist_hour["trip_distance"],
        text=f'Max: {max_dist_hour["trip_distance"]:.2f} miles',
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40
    )

    fig.add_annotation(
        x=min_dist_hour["hour"],
        y=min_dist_hour["trip_distance"],
        text=f'Min: {min_dist_hour["trip_distance"]:.2f} miles',
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=40
    )

    fig.show()

    # Stockage de l'information pour l'affichage
    max_hour_dist = int(max_dist_hour["hour"])
    min_hour_dist = int(min_dist_hour["hour"])

    # Cr√©ation du message d'observation
    observation_msg = f"Les trajets les plus longs ({max_dist_hour['trip_distance']:.2f} miles) sont observ√©s √† {max_hour_dist}h, "
    observation_msg += f"tandis que les plus courts ({min_dist_hour['trip_distance']:.2f} miles) sont √† {min_hour_dist}h."

    # Ajout d'un commentaire contextuel selon l'heure du maximum
    if max_hour_dist >= 22 or max_hour_dist <= 5:
        observation_msg += " Les distances plus longues en p√©riode nocturne pourraient s'expliquer par des trajets vers/depuis les a√©roports ou la p√©riph√©rie."
    elif 16 <= max_hour_dist < 20:
        observation_msg += " Les distances plus longues en fin de journ√©e pourraient correspondre √† des retours en banlieue apr√®s le travail."
    elif 6 <= max_hour_dist < 10:
        observation_msg += " Les distances plus longues t√¥t le matin pourraient correspondre √† des trajets domicile-travail depuis la p√©riph√©rie."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des distances moyennes par heure")
    observation_msg = "Donn√©es insuffisantes pour analyser les distances par heure."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìä Analyse de la Dur√©e des Trajets

```{python}
#| fig-cap: " "

if not df.empty and "duration" in df.columns:
    # Filtrage des dur√©es aberrantes (> 2h ou < 0)
    valid_durations = df[(df["duration"] > 0) & (df["duration"] < 120)]

    # Calcul des statistiques
    mean_duration = valid_durations["duration"].mean()
    median_duration = valid_durations["duration"].median()
    percentile_90 = valid_durations["duration"].quantile(0.9)

    # Cr√©ation de l'histogramme avec Plotly
    fig = ff.create_distplot(
        [valid_durations["duration"]],
        group_labels=["Dur√©e des trajets"],
        bin_size=1,
        show_rug=False,
        curve_type='normal'
    )

    y_vals = []
    for trace in fig.data:
        if hasattr(trace, 'y') and trace.y is not None:
            y_vals.extend(trace.y)
    y_max = max(y_vals) if y_vals else 0

    # Lignes verticales moyenne et m√©diane
    fig.add_shape(type="line",
                  x0=mean_duration, y0=0,
                  x1=mean_duration, y1=y_max,
                  line=dict(color="red", width=2, dash="dash"))
    fig.add_shape(type="line",
                  x0=median_duration, y0=0,
                  x1=median_duration, y1=y_max,
                  line=dict(color="green", width=2, dash="dash"))

    # Mise en page et annotations
    fig.update_layout(
        title="Distribution des Dur√©es de Trajet",
        xaxis_title="Dur√©e (minutes)",
        yaxis_title="Densit√©",
        width=1200, height=600,
        plot_bgcolor='rgba(240,240,240,0.5)',
        showlegend=False,
        annotations=[
            dict(x=mean_duration, y=y_max*0.95,
                 text=f"Moyenne: {mean_duration:.1f} min",
                 showarrow=False, font=dict(color="red")),
            dict(x=median_duration, y=y_max*0.85,
                 text=f"M√©diane: {median_duration:.1f} min",
                 showarrow=False, font=dict(color="green"))
        ]
    )
    fig.show()

    # Calcul pour l'observation
    skew = valid_durations["duration"].skew()

    # Construction du message d'observation
    observation_msg = f"90% des trajets durent moins de {percentile_90:.1f} minutes. "

    # Ajout d'une explication sur la distribution
    if skew > 1:
        observation_msg += "La distribution est fortement asym√©trique vers la droite, montrant que la majorit√© des trajets sont courts, mais quelques trajets tr√®s longs influencent la moyenne."
    elif skew > 0.5:
        observation_msg += "La distribution pr√©sente une asym√©trie mod√©r√©e vers la droite, sugg√©rant que la plupart des trajets sont de courte dur√©e."
    else:
        observation_msg += "La distribution est relativement sym√©trique, indiquant une r√©partition √©quilibr√©e des dur√©es de trajet."

    # Ajout d'une observation sur l'√©cart moyenne/m√©diane si significatif
    if mean_duration > median_duration * 1.2:
        observation_msg += f" L'√©cart significatif entre moyenne et m√©diane ({(mean_duration/median_duration - 1)*100:.0f}% de diff√©rence) confirme l'influence des trajets longs sur la distribution."
else:
    print("‚ö†Ô∏è Pas assez de donn√©es pour analyser les dur√©es")
    observation_msg = "Donn√©es insuffisantes pour analyser les dur√©es de trajet."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìä Analyse par Jour de la Semaine

```{python}
#| fig-cap: " "

if not df.empty and "weekday" in df.columns:
    # Ordre des jours de la semaine
    days_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    fr_days = {"Monday": "Lundi", "Tuesday": "Mardi", "Wednesday": "Mercredi",
               "Thursday": "Jeudi", "Friday": "Vendredi", "Saturday": "Samedi", "Sunday": "Dimanche"}

    # Conversion en jours fran√ßais si n√©cessaire
    if str(df["weekday"].iloc[0]) in fr_days.values():
        days_order = [fr_days[day] for day in days_order]

    # Pr√©paration des donn√©es
    weekday_counts = df["weekday"].value_counts().reindex(days_order).reset_index()
    weekday_counts.columns = ["weekday", "count"]

    # Ajout d'une colonne pour identifier les weekends
    weekday_counts["is_weekend"] = weekday_counts["weekday"].isin([days_order[-1], days_order[-2]])

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(
        weekday_counts,
        x="weekday",
        y="count",
        color="is_weekend",
        color_discrete_map={True: "orange", False: "royalblue"},
        labels={"weekday": "Jour de la semaine", "count": "Nombre de trajets", "is_weekend": "Weekend"},
        title="Nombre de trajets par jour de la semaine"
    )

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            categoryorder='array',
            categoryarray=days_order,
            title=" "
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200,
        showlegend=False
    )

    fig.show()

    # Identification du jour le plus et moins charg√©
    max_day_row = weekday_counts.loc[weekday_counts["count"].idxmax()]
    min_day_row = weekday_counts.loc[weekday_counts["count"].idxmin()]
    max_day = max_day_row["weekday"]
    min_day = min_day_row["weekday"]
    max_count = max_day_row["count"]
    min_count = min_day_row["count"]

    diff_pct = ((max_count - min_count) / min_count) * 100

    # Construction du message d'observation
    observation_msg = f"{max_day} est le jour le plus charg√© avec {int(max_count):,} trajets, "
    observation_msg += f"tandis que {min_day} est le moins actif avec {int(min_count):,} trajets, "
    observation_msg += f"soit une diff√©rence de {diff_pct:.1f}%. "

    # Analyse weekend vs semaine
    weekend_rows = weekday_counts[weekday_counts["is_weekend"]]
    weekday_rows = weekday_counts[~weekday_counts["is_weekend"]]

    weekend_avg = weekend_rows["count"].mean() if not weekend_rows.empty else 0
    weekday_avg = weekday_rows["count"].mean() if not weekday_rows.empty else 0

    if weekday_avg > 0:
        diff_we_pct = ((weekend_avg - weekday_avg) / weekday_avg) * 100

        if diff_we_pct > 10:
            observation_msg += f"Le weekend conna√Æt une hausse significative d'activit√© (+{diff_we_pct:.1f}%) par rapport √† la semaine, "
            observation_msg += "ce qui pourrait s'expliquer par les sorties nocturnes, √©v√©nements culturels et touristiques."
        elif diff_we_pct < -10:
            observation_msg += f"Le weekend conna√Æt une baisse significative d'activit√© ({diff_we_pct:.1f}%) par rapport √† la semaine, "
            observation_msg += "sugg√©rant que les d√©placements professionnels constituent une part importante de l'activit√© des taxis."
        else:
            observation_msg += "L'activit√© reste relativement stable entre les jours de semaine et le weekend, "
            observation_msg += "indiquant un √©quilibre entre les usages professionnels et de loisirs."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique par jour de la semaine")
    observation_msg = "Donn√©es insuffisantes pour analyser l'activit√© par jour de la semaine."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìÖ R√©partition des Trajets par Jour

```{python}
#| fig-cap: " "

if not df.empty and "date" in df.columns:
    # V√©rification de la pr√©sence de valeurs pour chaque jour du mois
    date_range = pd.date_range(df["date"].min(), df["date"].max())
    daily_counts = df.groupby("date").size().reset_index(name="trips")

    # Conversion au format datetime pour manipulation
    daily_counts["date"] = pd.to_datetime(daily_counts["date"])

    # S'assurer que tous les jours sont pr√©sents
    all_dates = pd.DataFrame({'date': date_range})
    daily_counts = pd.merge(all_dates, daily_counts, on='date', how='left').fillna(0)

    # Ajout du jour de la semaine
    daily_counts["weekday"] = daily_counts["date"].dt.day_name()
    daily_counts["is_weekend"] = daily_counts["date"].dt.dayofweek >= 5
    daily_counts["date_str"] = daily_counts["date"].dt.strftime('%d-%m (%a)')

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(
        daily_counts,
        x="date",
        y="trips",
        color="is_weekend",
        color_discrete_map={True: "orange", False: "royalblue"},
        labels={"date": "Date", "trips": "Nombre de trajets", "is_weekend": "Weekend"},
        title="Nombre de trajets par jour du mois"
    )

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            title=" ",
            tickmode='array',
            tickvals=daily_counts["date"],
            ticktext=daily_counts["date_str"],
            tickangle=45
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200,
        showlegend=False
    )

    fig.show()

    # Identification des jours significatifs
    # Filtrer pour √©liminer les valeurs aberrantes (jours avec tr√®s peu de trajets)
    valid_days = daily_counts[daily_counts["trips"] > daily_counts["trips"].max() * 0.1]

    if not valid_days.empty:
        max_day = valid_days.loc[valid_days["trips"].idxmax()]
        min_day = valid_days.loc[valid_days["trips"].idxmin()]
        max_date = max_day["date"].strftime('%d/%m/%Y (%A)')
        min_date = min_day["date"].strftime('%d/%m/%Y (%A)')

        # Construction du message d'observation
        observation_msg = f"Le jour avec le plus grand nombre de courses est le {max_date} "
        observation_msg += f"avec {int(max_day['trips']):,} trajets. "
        observation_msg += f"Le jour avec le moins de courses est le {min_date} "
        observation_msg += f"avec {int(min_day['trips']):,} trajets. "

        # Analyse de la tendance
        valid_days = valid_days.reset_index(drop=True)
        x = np.arange(len(valid_days))
        y = valid_days["trips"].values
        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

        if abs(r_value) > 0.5:
            trend = "forte"
        elif abs(r_value) > 0.3:
            trend = "mod√©r√©e"
        else:
            trend = "faible"

        if slope > 0:
            direction = "hausse"
        else:
            direction = "baisse"

        # Ajout de l'analyse de tendance
        observation_msg += f"Sur l'ensemble du mois, on observe une {trend} tendance √† la {direction} "
        observation_msg += f"de l'activit√© (r¬≤={r_value**2:.2f})."

        # Ajout d'une interpr√©tation possible
        if slope > 0 and r_value**2 > 0.3:
            observation_msg += " Cette hausse progressive pourrait indiquer une augmentation de la demande li√©e √† des facteurs saisonniers ou √©v√©nementiels."
        elif slope < 0 and r_value**2 > 0.3:
            observation_msg += " Cette baisse pourrait √™tre li√©e √† des facteurs saisonniers, des conditions m√©t√©orologiques, ou √† une augmentation de l'utilisation d'autres modes de transport."
    else:
        print("‚ö†Ô∏è Donn√©es insuffisantes pour analyser les tendances journali√®res")
        observation_msg = "Donn√©es insuffisantes pour analyser les tendances journali√®res."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des trajets par jour")
    observation_msg = "Donn√©es insuffisantes pour analyser la r√©partition des trajets par jour."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üí∞ Chiffre d'Affaires et Revenus

```{python}
#| fig-cap: " "

# S√©rie temporelle journali√®re
df['date'] = pd.to_datetime(df['pickup_datetime']).dt.date
daily_rev = df.groupby('date')['total_amount'].sum().reset_index(name='daily_revenue')
avg_rev = df['total_amount'].mean()

import plotly.express as px
fig = px.line(daily_rev, x='date', y='daily_revenue',
              labels={'date':'Date','daily_revenue':'Revenu total ($)'},
              title=f"Revenu total journalier et revenu moyen par course")
fig.update_layout(width=1200, height=600, plot_bgcolor='white')
fig.show()
```
```{python}
#| output: asis
max_rev = daily_rev['daily_revenue'].max()
min_rev = daily_rev['daily_revenue'].min()

observation_msg = f"Le revenu journalier maximal a atteint **${max_rev:,.0f}** et le minimum **${min_rev:,.0f}**. "
observation_msg += "Le revenu moyen par course s‚Äô√©tablit √† "
observation_msg += f"**${avg_rev:.2f}**, avec des variations marqu√©es selon les jours."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')
```

# üè∑Ô∏è R√©partition par Mode de Paiement

```{python}
#| fig-cap: " "
payment_counts = df['payment_method'].value_counts(normalize=False).reset_index()
payment_counts.columns = ['mode','count']
payment_counts['pct'] = payment_counts['count'] / payment_counts['count'].sum() * 100

fig = px.bar(payment_counts, y='mode', x='count', orientation='h',
             text=payment_counts['pct'].map('{:.1f}%'.format),
             title="Nombre de courses par mode de paiement")

fig.update_layout(
    width=1200,
    height=600,
    plot_bgcolor='white',
    yaxis={'categoryorder':'total ascending'},
    xaxis_title="",     # ‚Üê pas de titre axe X
    yaxis_title=""      # ‚Üê pas de titre axe Y
)
fig.show()
```

```{python}
#| output: asis
top_mode = payment_counts.loc[payment_counts['count'].idxmax()]

observation_msg = f"Le mode de paiement le plus utilis√© est **{top_mode['mode']}** "
observation_msg += f"avec **{top_mode['pct']:.1f}%** des courses."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')

```

# üó∫Ô∏è Carte des Prises en Charge par Zone

```{python}

# Charge le GeoJSON sous forme de GeoDataFrame
zones = gpd.read_file('data/taxi_zones.json')[['LocationID','zone','geometry']]

# Jointure avec les trajets
merged = zones.merge(
    df.groupby('PULocationID').size().reset_index(name='trips'),
    left_on='LocationID',
    right_on='PULocationID',
    how='left'
).fillna(0)

# Cr√©ation de la carte choropl√®the sur fond blanc
fig = px.choropleth(
    merged,
    geojson=merged.geometry.__geo_interface__,  # passage du GeoDataFrame en GeoJSON inline
    locations=merged.index,
    color='trips',
    color_continuous_scale="Blues",
    range_color=(0, merged['trips'].max()),
    title="Nombre de trajets par zone de prise en charge"
)

fig.update_geos(
    fitbounds="locations",
    visible=False
)

fig.update_layout(
    width=1000,
    height=800,
    paper_bgcolor="white",
    plot_bgcolor="white",
    coloraxis_colorbar=dict(
        title="Trajets",
        tickformat=".0f"
    )
)

fig.show()
```
```{python}
#| output: asis
top_zone = merged.loc[merged['trips'].idxmax()]

observation_msg = f"La zone ayant enregistr√© le plus de prises en charge est **{top_zone['zone']}** "
observation_msg += f"avec **{int(top_zone['trips']):,}** trajets."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')
```

# üîÑ Flux de Trajets entre Zones

```{python}
import plotly.graph_objects as go

# Top 10 des paires PU ‚Üí DO
pairs = df.groupby(['PULocationID', 'DOLocationID']).size().reset_index(name='count')
top_pairs = pairs.nlargest(10, 'count')

# Labels : r√©cup√©rer toutes les zones concern√©es
unique_locations = pd.unique(top_pairs[['PULocationID', 'DOLocationID']].values.ravel())

# Construire les labels et leur mapping d'index pour Sankey
zones_map = dict(zip(zones['LocationID'], zones['zone']))
labels = [zones_map.get(loc, f"ID {loc}") for loc in unique_locations]
label_idx = {loc: i for i, loc in enumerate(unique_locations)}

# Source, Target, Value
source = top_pairs['PULocationID'].map(label_idx)
target = top_pairs['DOLocationID'].map(label_idx)
value  = top_pairs['count']

# Cr√©ation du Sankey
fig = go.Figure(go.Sankey(
    node=dict(
        label=labels,
        pad=15,
        thickness=20,
        line=dict(color="black", width=0.5)
    ),
    link=dict(
        source=source,
        target=target,
        value=value
    )
))

fig.update_layout(
    title="Top 10 flux PU ‚Üí DO",
    font_size=12,
    width=1200,
    height=600,
    paper_bgcolor="white",
    plot_bgcolor="white"
)

fig.show()
```
```{python}
#| output: asis
top_pair = top_pairs.loc[top_pairs['count'].idxmax()]

observation_msg = f"La paire la plus fr√©quente de zones est "
observation_msg += f"**{zones_map.get(top_pair['PULocationID'], 'Inconnu')} ‚Üí {zones_map.get(top_pair['DOLocationID'], 'Inconnu')}** "
observation_msg += f"avec **{int(top_pair['count']):,}** trajets."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')
```

# üìè Tarif Moyen par Mile
```{python}
df['fare_per_mile'] = df['total_amount'] / df['trip_distance']
# Box‚Äëplot par tranche horaire
df['hour'] = pd.to_datetime(df['pickup_datetime']).dt.hour

fig = px.box(df, x='hour', y='fare_per_mile',
             labels={'hour':'Heure','fare_per_mile':'$ / mile'},
             title="Distribution du tarif ($) par mile selon l‚Äôheure")
fig.update_layout(width=1200, height=600, plot_bgcolor='white')
fig.show()
```

```{python}
#| output: asis
max_fpm = df['fare_per_mile'].max()
mean_fpm = df['fare_per_mile'].mean()
observation_msg = f"Le tarif moyen par mile est de **${mean_fpm:.2f}**, avec un maximum observ√© √† **${max_fpm:.2f}**."
observation_msg += " Les valeurs extr√™mes peuvent √™tre dues √† des trajets tr√®s courts avec minimum de prise en charge √©lev√©."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')

```
# üë• Nombre de Passagers et Indicateurs

```{python}
# R√©partition passager_count
pc = df['passenger_count'].value_counts().reset_index()
pc.columns = ['passengers','count']

fig = px.bar(pc, x='passengers', y='count',
             labels={'passengers':' ','count':' '},
             title="Distribution du nombre de passagers par course")
fig.update_layout(width=1200, height=600, plot_bgcolor='white')
fig.show()
```

```{python}
# KPI par nombre de passagers
group = df.groupby('passenger_count').agg({
    'total_amount':'mean',
    'tip_amount':'mean'
}).reset_index().round(2)

# Cr√©ation du graphique
fig = go.Figure()

# Barre revenu moyen
fig.add_trace(go.Bar(
    y=group['passenger_count'],
    x=group['total_amount'],
    name='Revenu moyen ($)',
    orientation='h',
    marker_color='royalblue'
))

# Barre pourboire moyen
fig.add_trace(go.Bar(
    y=group['passenger_count'],
    x=group['tip_amount'],
    name='Pourboire moyen ($)',
    orientation='h',
    marker_color='orange'
))

# Mise en forme du graphique
fig.update_layout(
    barmode='group',
    title="Revenu et pourboire moyen par nombre de passagers",
    xaxis_title="Montant moyen ($)",
    yaxis_title="Nombre de passagers",
    height=600,
    width=1000,
    paper_bgcolor="white",
    plot_bgcolor="white"
)

fig.show()
```
```{python}
#| output: asis
top_group = group.loc[group['total_amount'].idxmax()]

observation_msg = f"Les trajets avec **{int(top_group['passenger_count'])} passager(s)** rapportent en moyenne le revenu le plus √©lev√© √† **${top_group['total_amount']:.2f}**."
observation_msg += f" Le pourboire moyen dans cette cat√©gorie est de **${top_group['tip_amount']:.2f}**."

print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
print(f'  <p>{observation_msg}</p>')
print('</div>')
```

# üìå Synth√®se du Mois

```{python}
#| echo: false
# Variables pour la synth√®se
if not df.empty and "trip_distance" in df.columns and "hour" in df.columns:
    # Top 3 des heures les plus actives
    hourly_trips = df.groupby("hour").size()
    peak_hours = hourly_trips.sort_values(ascending=False).head(3).index.tolist()
    peak_hours_range = f"{min(peak_hours)}h et {max(peak_hours)}h"

    avg_distance_rounded = round(avg_distance, 2)
else:
    peak_hours_range = "17h et 20h"
    avg_distance_rounded = 0
```

```{python}
#| output: asis
print(f"- üìà L‚Äôactivit√© maximale se concentre g√©n√©ralement entre **{peak_hours_range}** selon les donn√©es disponibles.")
print(f"- üõ£Ô∏è Distance moyenne des trajets : **{avg_distance_rounded:.2f} miles**")
print(f"- üíµ Revenu moyen par course : **${avg_rev:.2f}**")
print(f"- üìä Zone la plus fr√©quent√©e : **{top_zone['zone']}** avec **{int(top_zone['trips']):,}** prises en charge.")
print(f"- üè∑Ô∏è Mode de paiement le plus utilis√© : **{top_mode['mode']}** ({top_mode['pct']:.1f}%)")
print(f"- üìå Tarif moyen par mile : **${mean_fpm:.2f}**")
```

# üöÄ Recommandations pour les Prochains Mois

* Pousser l‚Äôanalyse du chiffre d‚Äôaffaires journalier et des variations hebdomadaires.

* Suivre l‚Äô√©volution des modes de paiement (essor ou d√©clin de certaines pratiques).

* Localiser les zones les plus actives pour adapter les ressources taxi et campagnes marketing.

* Suivre les flux inter-zones principaux pour planifier la logistique et anticiper les congestions.

* Int√©grer des analyses de tarifs par mile et dur√©es pour d√©tecter les anomalies tarifaires.

* √âtendre le rapport aux indicateurs de pourboire et passagers pour affiner les segments de client√®le.

