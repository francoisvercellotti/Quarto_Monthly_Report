---
title: "üöñ Rapport Mensuel Courses de Taxi ‚Äî New York"
author: "Fran√ßois Vercellotti"
date: today

format:
  html:
    theme: cosmo
    toc: true
    toc-title: "Sommaire"
    toc-location: left
    toc-float: true
    number-sections: true
    code-fold: true
    code-summary: "Afficher le code"
    self-contained: true
    html-math-method: mathjax
    page-layout: full
    fig-responsive: true
    include-in-header:
      text: |
        <style>
          /* Police et tailles g√©n√©rales */
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;  /* Augmentation de la taille de base */
            line-height: 1.6;
          }

          /* Titre principal */
          h1.title {
            font-size: 3em !important;  /* Titre principal plus grand */
            margin-bottom: 0.8em !important;
            font-weight: 600 !important;
          }

          /* Sous-titres - Respect de la hi√©rarchie */
          h2 {
            font-size: 2.2em !important;
            margin-top: 1.5em !important;
          }

          h3 {
            font-size: 1.8em !important;
          }

          h4 {
            font-size: 1.5em !important;
          }

          h5 {
            font-size: 1.3em !important;
          }

          /* Assure la hi√©rarchie des titres num√©rot√©s */
          .header-section-number {
            font-weight: 600;
          }

          /* Correction pour garantir que les sous-niveaux (4.2) ne sont jamais plus grands que les niveaux sup√©rieurs (4) */
          h1 .header-section-number + span,
          h2 .header-section-number + span,
          h3 .header-section-number + span,
          h4 .header-section-number + span,
          h5 .header-section-number + span {
            font-size: inherit !important;
          }

          /* Paragraphes */
          p {
            font-size: 1.1em;
            margin-bottom: 1.2em;
          }

          /* Conteneur principal */
          #quarto-content {
            max-width: 2000px;
            margin: 0 auto;
            padding: 0 2em;
          }

          /* Alignement des cellules de layout */
          .cell.quarto-layout-cell {
            padding-left: 0 !important;
            padding-right: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
          }

          /* Alignement g√©n√©ral */
          .quarto-title, .quarto-title-meta, .cell-output, .cell {
            text-align: left !important;
            margin-left: 0 !important;
            padding-left: 0 !important;
          }

          /* Figures : suppression de tout d√©calage lat√©ral */
          .figure,
          .figure-img,
          .cell-output-display,
          .plot-output,
          .plotly-graph-div,
          .bokeh,
          .altair-render,
          .ggplot {
            margin-left: 0 !important;
            margin-right: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow: visible !important;
          }

          /* Supprime les styles inline de centering de Plotly */
          .cell-output-display .plotly-graph-div[style*="margin"] {
            margin: 0 !important;
          }

          /* Pour les images/SVG de Matplotlib et autres */
          .cell-output-display img[width],
          .cell-output-display svg[width] {
            width: 100% !important;
            height: auto !important;
            margin: 0 !important;
          }

          /* R√©duction de la taille de la barre d'outils Plotly */
          .plotly .modebar {
            transform: scale(0.7) !important;
            transform-origin: top right !important;
          }

          .plotly .modebar-container {
            right: 5px !important;
            top: 5px !important;
          }

          .plotly .modebar-btn {
            width: 1.6em !important;
            height: 1.6em !important;
            padding: 0.2em !important;
          }

          .plotly .modebar-btn svg {
            transform: scale(0.7) !important;
          }

          /* Espacement et taille du code */
          pre, code {
            font-size: 0.95em;
          }

          .cell-output {
            font-size: 1.15em;
            margin-top: 1em;
            margin-bottom: 2em;
          }

          /* Table des mati√®res */
          #toc-title {
            font-size: 1.4em !important;
            font-weight: 600 !important;
          }

          #TOC {
            font-size: 1.05em;
          }
        </style>

jupyter: python3
params:
  month_code: "2023-07"

execute:
  fig-width: 10
  fig-height: 6
  fig-format: "retina"
  fig-responsive: true
  out-width: "100%"
---


# üìå Contexte et Objectifs

Ce rapport pr√©sente l'analyse de l'activit√© des taxis √† New York pour le mois s√©lectionn√©.

Les objectifs sont les suivants :

* Suivre les indicateurs cl√©s de performance (KPI) des courses : nombre de trajets, distances parcourues et dur√©es.
* Identifier les p√©riodes de forte activit√©.
* Analyser les tendances et variations dans l'activit√© des taxis.
* Fournir des visualisations claires pour faciliter la compr√©hension des donn√©es.

---

# üìä Donn√©es utilis√©es

Les analyses reposent sur les donn√©es suivantes :

* **Donn√©es Taxi** : informations sur les trajets (prise en charge, d√©pose, distance, dur√©e) pour le mois analys√©.

---

# üì• Pr√©paration et Traitement des Donn√©es

Les donn√©es taxi sont charg√©es pour analyse.

```{python}
import pandas as pd
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
import os
import re
import yaml
from scipy import stats
import numpy as np

# Lecture du fichier settings.yaml pour obtenir le mois du rapport
# Si le fichier n'est pas trouv√©, utilisez une valeur par d√©faut
try:
    with open("config/settings.yaml", 'r') as file:
        settings = yaml.safe_load(file)
        month_code = settings.get('report_month', '2023-07')
except Exception as e:
    print(f"‚ö†Ô∏è Erreur lors de la lecture du fichier settings.yaml: {e}")
    month_code = '2023-07'  # Valeur par d√©faut


# Conversion en format lisible
try:
    date_obj = datetime.strptime(month_code, "%Y-%m")
    month_name = date_obj.strftime("%B %Y")
except:
    month_name = "Inconnu"


# Chargement des donn√©es taxi uniquement
try:
    df_taxi = pd.read_csv(f"data/{month_code}-taxi.csv", parse_dates=["pickup_datetime", "dropoff_datetime"])

    # Pr√©paration des donn√©es
    df_taxi["hour"] = df_taxi["pickup_datetime"].dt.hour
    df_taxi["weekday"] = df_taxi["pickup_datetime"].dt.day_name()
    df_taxi["date"] = df_taxi["pickup_datetime"].dt.date
    df_taxi["duration"] = (df_taxi["dropoff_datetime"] - df_taxi["pickup_datetime"]).dt.total_seconds() / 60

    # Filtrer les dur√©es n√©gatives ou aberrantes (>180 min)
    df_taxi = df_taxi[(df_taxi["duration"] > 0) & (df_taxi["duration"] < 180)]

    # Filtrer les distances aberrantes (>50 miles)
    df_taxi = df_taxi[df_taxi["trip_distance"] < 50]

    # Utilisation directe des donn√©es taxi pour l'analyse
    df = df_taxi.copy()
except Exception as e:
    print(f"‚ùå Erreur lors du chargement des donn√©es taxi: {e}")
    # Cr√©ation d'un DataFrame vide pour √©viter les erreurs
    df = pd.DataFrame(columns=["pickup_datetime", "dropoff_datetime", "trip_distance", "hour", "weekday", "date"])
    print("‚ö†Ô∏è Aucune donn√©e taxi disponible, rapport limit√©")
```

```{python}
#| output: asis
# G√©n√©ration "√† la vol√©e" du bloc d'information sur la p√©riode en Markdown
print(f"## Configuration pour le rapport du mois de **{month_name}**")
print()
print(f"- üìÖ P√©riode d'analyse : **{month_name}**")
print(f"- üóìÔ∏è Code p√©riode : **{month_code}**")
print(f"- üìä Fichier de donn√©es : **data/{month_code}-taxi.csv**")
print(f"- üî¢ Nombre d'enregistrements : **{len(df_taxi):,}**")
# üìà Indicateurs Cl√©s de Performance (KPIs)
```

```{python}
#| echo: false

# Calcul des KPIs avec gestion des erreurs
if not df.empty:
    total_trips = len(df)
    avg_distance = df["trip_distance"].mean() if "trip_distance" in df.columns else 0
    avg_distance_rounded = round(avg_distance, 2)

    if "duration" in df.columns:
        avg_duration = df["duration"].mean()
        # Identification des heures de pointe bas√©e sur les donn√©es r√©elles
        hourly_trips = df.groupby("hour").size()
        peak_hours = hourly_trips.sort_values(ascending=False).head(3).index.tolist()
        peak_hours.sort()  # Trier les heures par ordre croissant
        peak_hours_str = ", ".join([f"{h}h" for h in peak_hours])
    else:
        avg_duration = 0
        peak_hours_str = "Non d√©termin√©"

    # Jour de la semaine le plus charg√©
    if "weekday" in df.columns:
        busiest_day = df.groupby("weekday").size().idxmax()
    else:
        busiest_day = "Non d√©termin√©"
else:
    total_trips = 0
    avg_distance = 0
    avg_distance_rounded = 0
    avg_duration = 0
    peak_hours_str = "Non d√©termin√©"
    busiest_day = "Non d√©termin√©"
```

```{python}
#| output: asis
# G√©n√©ration "√† la vol√©e" du bloc KPI en Markdown
print(f"## Rapport de trafic du mois de **{month_name}**")
print()
print(f"- üìä Nombre total de trajets‚ÄØ: **{total_trips:,}**")
print(f"- üõ£Ô∏è Distance moyenne parcourue‚ÄØ: **{avg_distance_rounded:.1f}** miles")
print(f"- ‚è±Ô∏è Dur√©e moyenne d‚Äôun trajet‚ÄØ: **{avg_duration:.1f}** minutes")
print(f"- üïò Heures de pointe‚ÄØ: **{peak_hours_str}**")
print(f"- üìÖ Jour le plus charg√©‚ÄØ: **{busiest_day}**")
```

# üìä Analyse de l'Activit√© par Heure de la Journ√©e

## Volume de trajets par heure

Ce graphique pr√©sente la r√©partition du nombre de trajets en fonction de l'heure de la journ√©e.

```{python}
#| fig-cap: " "

# V√©rification que df existe et contient la colonne "hour"
if 'df' in globals() and not df.empty and "hour" in df.columns:
    # Pr√©paration des donn√©es
    hourly_counts = df["hour"].value_counts().sort_index().reset_index()
    hourly_counts.columns = ["hour", "count"]

    # Heure avec le plus de trajets
    max_hour = hourly_counts.loc[hourly_counts["count"].idxmax()]

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(hourly_counts, x="hour", y="count",
                 labels={"hour": "Heure", "count": "Nombre de trajets"},
                 title=" ")

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            tickmode='linear',
            tick0=0,
            dtick=1,
            title=" "
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200
    )

    # Ajout d'annotation pour le pic
    fig.add_annotation(
        x=max_hour["hour"],
        y=max_hour["count"],
        text=f"Pic: {max_hour['count']:,} trajets",
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40
    )

    fig.show()

    # Stockage de l'information pour l'affichage
    peak_hour = int(max_hour["hour"])

    # D√©termination du message appropri√©
    if peak_hour < 6:
        observation_msg = f"Le pic d'activit√© est observ√© tr√®s t√¥t, √† **{peak_hour}h**, sugg√©rant une forte demande matinale."
    elif 6 <= peak_hour < 10:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, correspondant √† l'heure de pointe matinale."
    elif 10 <= peak_hour < 16:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, durant la p√©riode de mi-journ√©e."
    elif 16 <= peak_hour < 20:
        observation_msg = f"Le pic d'activit√© est observ√© √† **{peak_hour}h**, correspondant √† l'heure de pointe en fin de journ√©e."
    else:
        observation_msg = f"Le pic d'activit√© est observ√© en soir√©e, √† **{peak_hour}h**, sugg√©rant une forte demande nocturne."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des trajets par heure")
    observation_msg = "Donn√©es insuffisantes pour g√©n√©rer l'observation."
```

```{python}
#| output: asis

# Utilisation de la m√™me technique avec output: asis pour g√©n√©rer le bloc d'observation
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

## Distance moyenne parcourue par heure

```{python}
#| fig-cap: " "

if not df.empty and "hour" in df.columns and "trip_distance" in df.columns:
    # Calcul des distances moyennes par heure
    dist_hour = df.groupby("hour")["trip_distance"].mean().reset_index()

    # Identification de l'heure avec la distance moyenne maximale et minimale
    max_dist_hour = dist_hour.loc[dist_hour["trip_distance"].idxmax()]
    min_dist_hour = dist_hour.loc[dist_hour["trip_distance"].idxmin()]

    # Cr√©ation du graphique avec Plotly
    fig = go.Figure()

    # Ajout de la ligne principale
    fig.add_trace(go.Scatter(
        x=dist_hour["hour"],
        y=dist_hour["trip_distance"],
        mode='lines+markers',
        name='Distance moyenne',
        line=dict(color='royalblue', width=3),
        marker=dict(size=8)
    ))

    # Mise en forme du graphique
    fig.update_layout(
        title="Distance moyenne par heure",
        xaxis=dict(
            title=" ",
            tickmode='linear',
            tick0=0,
            dtick=1
        ),
        yaxis=dict(
            title="Distance moyenne (miles)"
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200
    )

    # Ajout d'annotations pour les points maximum et minimum
    fig.add_annotation(
        x=max_dist_hour["hour"],
        y=max_dist_hour["trip_distance"],
        text=f'Max: {max_dist_hour["trip_distance"]:.2f} miles',
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40
    )

    fig.add_annotation(
        x=min_dist_hour["hour"],
        y=min_dist_hour["trip_distance"],
        text=f'Min: {min_dist_hour["trip_distance"]:.2f} miles',
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=40
    )

    fig.show()

    # Stockage de l'information pour l'affichage
    max_hour_dist = int(max_dist_hour["hour"])
    min_hour_dist = int(min_dist_hour["hour"])

    # Cr√©ation du message d'observation
    observation_msg = f"Les trajets les plus longs ({max_dist_hour['trip_distance']:.2f} miles) sont observ√©s √† {max_hour_dist}h, "
    observation_msg += f"tandis que les plus courts ({min_dist_hour['trip_distance']:.2f} miles) sont √† {min_hour_dist}h."

    # Ajout d'un commentaire contextuel selon l'heure du maximum
    if max_hour_dist >= 22 or max_hour_dist <= 5:
        observation_msg += " Les distances plus longues en p√©riode nocturne pourraient s'expliquer par des trajets vers/depuis les a√©roports ou la p√©riph√©rie."
    elif 16 <= max_hour_dist < 20:
        observation_msg += " Les distances plus longues en fin de journ√©e pourraient correspondre √† des retours en banlieue apr√®s le travail."
    elif 6 <= max_hour_dist < 10:
        observation_msg += " Les distances plus longues t√¥t le matin pourraient correspondre √† des trajets domicile-travail depuis la p√©riph√©rie."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des distances moyennes par heure")
    observation_msg = "Donn√©es insuffisantes pour analyser les distances par heure."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìä Analyse de la Dur√©e des Trajets

```{python}
#| fig-cap: " "

if not df.empty and "duration" in df.columns:
    # Filtrage des dur√©es aberrantes (> 2h ou < 0)
    valid_durations = df[(df["duration"] > 0) & (df["duration"] < 120)]

    # Calcul des statistiques
    mean_duration = valid_durations["duration"].mean()
    median_duration = valid_durations["duration"].median()
    percentile_90 = valid_durations["duration"].quantile(0.9)

    # Cr√©ation de l'histogramme avec Plotly
    fig = ff.create_distplot(
        [valid_durations["duration"]],
        group_labels=["Dur√©e des trajets"],
        bin_size=1,
        show_rug=False,
        curve_type='normal'
    )

    y_vals = []
    for trace in fig.data:
        if hasattr(trace, 'y') and trace.y is not None:
            y_vals.extend(trace.y)
    y_max = max(y_vals) if y_vals else 0

    # Lignes verticales moyenne et m√©diane
    fig.add_shape(type="line",
                  x0=mean_duration, y0=0,
                  x1=mean_duration, y1=y_max,
                  line=dict(color="red", width=2, dash="dash"))
    fig.add_shape(type="line",
                  x0=median_duration, y0=0,
                  x1=median_duration, y1=y_max,
                  line=dict(color="green", width=2, dash="dash"))

    # Mise en page et annotations
    fig.update_layout(
        title="Distribution des Dur√©es de Trajet",
        xaxis_title="Dur√©e (minutes)",
        yaxis_title="Densit√©",
        width=1200, height=600,
        plot_bgcolor='rgba(240,240,240,0.5)',
        showlegend=False,
        annotations=[
            dict(x=mean_duration, y=y_max*0.95,
                 text=f"Moyenne: {mean_duration:.1f} min",
                 showarrow=False, font=dict(color="red")),
            dict(x=median_duration, y=y_max*0.85,
                 text=f"M√©diane: {median_duration:.1f} min",
                 showarrow=False, font=dict(color="green"))
        ]
    )
    fig.show()

    # Calcul pour l'observation
    skew = valid_durations["duration"].skew()

    # Construction du message d'observation
    observation_msg = f"90% des trajets durent moins de {percentile_90:.1f} minutes. "

    # Ajout d'une explication sur la distribution
    if skew > 1:
        observation_msg += "La distribution est fortement asym√©trique vers la droite, montrant que la majorit√© des trajets sont courts, mais quelques trajets tr√®s longs influencent la moyenne."
    elif skew > 0.5:
        observation_msg += "La distribution pr√©sente une asym√©trie mod√©r√©e vers la droite, sugg√©rant que la plupart des trajets sont de courte dur√©e."
    else:
        observation_msg += "La distribution est relativement sym√©trique, indiquant une r√©partition √©quilibr√©e des dur√©es de trajet."

    # Ajout d'une observation sur l'√©cart moyenne/m√©diane si significatif
    if mean_duration > median_duration * 1.2:
        observation_msg += f" L'√©cart significatif entre moyenne et m√©diane ({(mean_duration/median_duration - 1)*100:.0f}% de diff√©rence) confirme l'influence des trajets longs sur la distribution."
else:
    print("‚ö†Ô∏è Pas assez de donn√©es pour analyser les dur√©es")
    observation_msg = "Donn√©es insuffisantes pour analyser les dur√©es de trajet."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìä Analyse par Jour de la Semaine

```{python}
#| fig-cap: " "

if not df.empty and "weekday" in df.columns:
    # Ordre des jours de la semaine
    days_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    fr_days = {"Monday": "Lundi", "Tuesday": "Mardi", "Wednesday": "Mercredi",
               "Thursday": "Jeudi", "Friday": "Vendredi", "Saturday": "Samedi", "Sunday": "Dimanche"}

    # Conversion en jours fran√ßais si n√©cessaire
    if str(df["weekday"].iloc[0]) in fr_days.values():
        days_order = [fr_days[day] for day in days_order]

    # Pr√©paration des donn√©es
    weekday_counts = df["weekday"].value_counts().reindex(days_order).reset_index()
    weekday_counts.columns = ["weekday", "count"]

    # Ajout d'une colonne pour identifier les weekends
    weekday_counts["is_weekend"] = weekday_counts["weekday"].isin([days_order[-1], days_order[-2]])

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(
        weekday_counts,
        x="weekday",
        y="count",
        color="is_weekend",
        color_discrete_map={True: "orange", False: "royalblue"},
        labels={"weekday": "Jour de la semaine", "count": "Nombre de trajets", "is_weekend": "Weekend"},
        title="Nombre de trajets par jour de la semaine"
    )

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            categoryorder='array',
            categoryarray=days_order,
            title=" "
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200,
        showlegend=False
    )

    fig.show()

    # Identification du jour le plus et moins charg√©
    max_day_row = weekday_counts.loc[weekday_counts["count"].idxmax()]
    min_day_row = weekday_counts.loc[weekday_counts["count"].idxmin()]
    max_day = max_day_row["weekday"]
    min_day = min_day_row["weekday"]
    max_count = max_day_row["count"]
    min_count = min_day_row["count"]

    diff_pct = ((max_count - min_count) / min_count) * 100

    # Construction du message d'observation
    observation_msg = f"{max_day} est le jour le plus charg√© avec {int(max_count):,} trajets, "
    observation_msg += f"tandis que {min_day} est le moins actif avec {int(min_count):,} trajets, "
    observation_msg += f"soit une diff√©rence de {diff_pct:.1f}%. "

    # Analyse weekend vs semaine
    weekend_rows = weekday_counts[weekday_counts["is_weekend"]]
    weekday_rows = weekday_counts[~weekday_counts["is_weekend"]]

    weekend_avg = weekend_rows["count"].mean() if not weekend_rows.empty else 0
    weekday_avg = weekday_rows["count"].mean() if not weekday_rows.empty else 0

    if weekday_avg > 0:
        diff_we_pct = ((weekend_avg - weekday_avg) / weekday_avg) * 100

        if diff_we_pct > 10:
            observation_msg += f"Le weekend conna√Æt une hausse significative d'activit√© (+{diff_we_pct:.1f}%) par rapport √† la semaine, "
            observation_msg += "ce qui pourrait s'expliquer par les sorties nocturnes, √©v√©nements culturels et touristiques."
        elif diff_we_pct < -10:
            observation_msg += f"Le weekend conna√Æt une baisse significative d'activit√© ({diff_we_pct:.1f}%) par rapport √† la semaine, "
            observation_msg += "sugg√©rant que les d√©placements professionnels constituent une part importante de l'activit√© des taxis."
        else:
            observation_msg += "L'activit√© reste relativement stable entre les jours de semaine et le weekend, "
            observation_msg += "indiquant un √©quilibre entre les usages professionnels et de loisirs."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique par jour de la semaine")
    observation_msg = "Donn√©es insuffisantes pour analyser l'activit√© par jour de la semaine."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìÖ R√©partition des Trajets par Jour

```{python}
#| fig-cap: " "

if not df.empty and "date" in df.columns:
    # V√©rification de la pr√©sence de valeurs pour chaque jour du mois
    date_range = pd.date_range(df["date"].min(), df["date"].max())
    daily_counts = df.groupby("date").size().reset_index(name="trips")

    # Conversion au format datetime pour manipulation
    daily_counts["date"] = pd.to_datetime(daily_counts["date"])

    # S'assurer que tous les jours sont pr√©sents
    all_dates = pd.DataFrame({'date': date_range})
    daily_counts = pd.merge(all_dates, daily_counts, on='date', how='left').fillna(0)

    # Ajout du jour de la semaine
    daily_counts["weekday"] = daily_counts["date"].dt.day_name()
    daily_counts["is_weekend"] = daily_counts["date"].dt.dayofweek >= 5
    daily_counts["date_str"] = daily_counts["date"].dt.strftime('%d-%m (%a)')

    # Cr√©ation du graphique avec Plotly
    fig = px.bar(
        daily_counts,
        x="date",
        y="trips",
        color="is_weekend",
        color_discrete_map={True: "orange", False: "royalblue"},
        labels={"date": "Date", "trips": "Nombre de trajets", "is_weekend": "Weekend"},
        title="Nombre de trajets par jour du mois"
    )

    # Mise en forme du graphique
    fig.update_layout(
        xaxis=dict(
            title=" ",
            tickmode='array',
            tickvals=daily_counts["date"],
            ticktext=daily_counts["date_str"],
            tickangle=45
        ),
        yaxis=dict(
            title=" "
        ),
        plot_bgcolor='rgba(240, 240, 240, 0.5)',
        height=600,
        width=1200,
        showlegend=False
    )

    fig.show()

    # Identification des jours significatifs
    # Filtrer pour √©liminer les valeurs aberrantes (jours avec tr√®s peu de trajets)
    valid_days = daily_counts[daily_counts["trips"] > daily_counts["trips"].max() * 0.1]

    if not valid_days.empty:
        max_day = valid_days.loc[valid_days["trips"].idxmax()]
        min_day = valid_days.loc[valid_days["trips"].idxmin()]
        max_date = max_day["date"].strftime('%d/%m/%Y (%A)')
        min_date = min_day["date"].strftime('%d/%m/%Y (%A)')

        # Construction du message d'observation
        observation_msg = f"Le jour avec le plus grand nombre de courses est le {max_date} "
        observation_msg += f"avec {int(max_day['trips']):,} trajets. "
        observation_msg += f"Le jour avec le moins de courses est le {min_date} "
        observation_msg += f"avec {int(min_day['trips']):,} trajets. "

        # Analyse de la tendance
        valid_days = valid_days.reset_index(drop=True)
        x = np.arange(len(valid_days))
        y = valid_days["trips"].values
        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

        if abs(r_value) > 0.5:
            trend = "forte"
        elif abs(r_value) > 0.3:
            trend = "mod√©r√©e"
        else:
            trend = "faible"

        if slope > 0:
            direction = "hausse"
        else:
            direction = "baisse"

        # Ajout de l'analyse de tendance
        observation_msg += f"Sur l'ensemble du mois, on observe une {trend} tendance √† la {direction} "
        observation_msg += f"de l'activit√© (r¬≤={r_value**2:.2f})."

        # Ajout d'une interpr√©tation possible
        if slope > 0 and r_value**2 > 0.3:
            observation_msg += " Cette hausse progressive pourrait indiquer une augmentation de la demande li√©e √† des facteurs saisonniers ou √©v√©nementiels."
        elif slope < 0 and r_value**2 > 0.3:
            observation_msg += " Cette baisse pourrait √™tre li√©e √† des facteurs saisonniers, des conditions m√©t√©orologiques, ou √† une augmentation de l'utilisation d'autres modes de transport."
    else:
        print("‚ö†Ô∏è Donn√©es insuffisantes pour analyser les tendances journali√®res")
        observation_msg = "Donn√©es insuffisantes pour analyser les tendances journali√®res."
else:
    print("‚ö†Ô∏è Donn√©es insuffisantes pour g√©n√©rer le graphique des trajets par jour")
    observation_msg = "Donn√©es insuffisantes pour analyser la r√©partition des trajets par jour."
```

```{python}
#| output: asis

# Affichage du bloc d'observation format√©
if 'observation_msg' in globals():
    print('<div style="background-color: #f0f7fb; border-left: 5px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 3px;">')
    print('  <h4 style="margin-top: 0; color: #3498db;">Observation</h4>')
    print(f'  <p>{observation_msg}</p>')
    print('</div>')
```

# üìå Synth√®se du Mois

```{python}
#| echo: false
# Variables pour la synth√®se
if not df.empty and "trip_distance" in df.columns and "hour" in df.columns:
    # Top 3 des heures les plus actives
    hourly_trips = df.groupby("hour").size()
    peak_hours = hourly_trips.sort_values(ascending=False).head(3).index.tolist()
    peak_hours_range = f"{min(peak_hours)}h et {max(peak_hours)}h"

    avg_distance_rounded = round(avg_distance, 2)
else:
    peak_hours_range = "17h et 20h"
    avg_distance_rounded = 0
```

```{python}
#| output: asis
# Synth√®se "√† la vol√©e" en Markdown
print(f"- üìà L'activit√© maximale se concentre g√©n√©ralement entre **{peak_hours_range}** selon les donn√©es disponibles.")
print(f"- üõ£Ô∏è Distance moyenne des trajets : **{avg_distance_rounded:.2f} Miles**")
print(f"- üìÜ Une analyse plus d√©taill√©e de la r√©partition journali√®re est disponible dans les graphiques ci-dessus.")
```

# üöÄ Recommandations pour les Prochains Mois

* Int√©grer le montant des courses et des pourboires pour enrichir les analyses √©conomiques.
* Identifier les zones g√©ographiques les plus actives via des cartes interactives.
* √âtudier plus en d√©tail l'impact des facteurs externes comme les √©v√©nements ou la saisonnalit√© sur le nombre de courses.
* Croiser les donn√©es avec des √©v√©nements locaux (concerts, matchs, conventions) pour expliquer certains pics.